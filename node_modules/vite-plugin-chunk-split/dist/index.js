"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.chunkSplitPlugin = void 0;
const assert_1 = __importDefault(require("assert"));
const path_1 = __importDefault(require("path"));
const staticImportScan_1 = require("./staticImportScan");
const helper_1 = require("./helper");
const utils_1 = require("./utils");
const es_module_lexer_1 = require("es-module-lexer");
const magic_string_1 = __importDefault(require("magic-string"));
const SPLIT_DEFAULT_MODULES = {
    __commonjsHelpers__: [/commonjsHelpers/],
};
const cache = new Map();
const wrapCustomSplitConfig = (manualChunks, customOptions, customChunk, root) => __awaiter(void 0, void 0, void 0, function* () {
    (0, assert_1.default)(typeof manualChunks === "function");
    const groups = Object.keys(customOptions);
    // Create cache ahead of time to decrease the cost of resolve.sync!
    const depsInGroup = {};
    for (const group of groups) {
        const packageInfo = customOptions[group];
        depsInGroup[group] = yield Promise.all(packageInfo
            .filter((item) => typeof item === "string")
            .map((item) => (0, utils_1.resolveEntry)(item, root)));
        depsInGroup[group] = depsInGroup[group].filter((item) => item.length > 0);
    }
    return (moduleId, { getModuleIds, getModuleInfo }) => {
        const isDepInclude = (id, depPaths, importChain) => {
            // compat windows
            id = (0, utils_1.normalizePath)(id);
            const key = `${id}-${depPaths.join("|")}`;
            // circular dependency
            if (importChain.includes(id)) {
                cache.set(key, false);
                return false;
            }
            if (cache.has(key)) {
                return cache.get(key);
            }
            // hit
            if (depPaths.includes(id)) {
                importChain.forEach((item) => cache.set(`${item}-${depPaths.join("|")}`, true));
                return true;
            }
            const moduleInfo = getModuleInfo(id);
            if (!moduleInfo || !moduleInfo.importers) {
                cache.set(key, false);
                return false;
            }
            const isInclude = moduleInfo.importers.some((importer) => isDepInclude(importer, depPaths, importChain.concat(id)));
            // set cache, important!
            cache.set(key, isInclude);
            return isInclude;
        };
        const id = (0, utils_1.normalizePath)(moduleId);
        const chunk = customChunk({
            id,
            moduleId,
            root,
            file: (0, utils_1.normalizePath)(path_1.default.relative(root, id)),
        });
        if (chunk) {
            return chunk;
        }
        for (const group of groups) {
            const deps = depsInGroup[group];
            const packageInfo = customOptions[group];
            if (!(0, helper_1.isCSSIdentifier)(moduleId)) {
                if (moduleId.includes("node_modules") &&
                    deps.length &&
                    isDepInclude(moduleId, deps, [])) {
                    return group;
                }
                for (const rule of packageInfo) {
                    if (rule instanceof RegExp && rule.test(moduleId)) {
                        return group;
                    }
                }
            }
        }
        return manualChunks(moduleId, { getModuleIds, getModuleInfo });
    };
});
const generateManualChunks = (splitOptions, root) => __awaiter(void 0, void 0, void 0, function* () {
    const { strategy = "default", customSplitting = {}, customChunk = () => null } = splitOptions;
    if (strategy === "all-in-one") {
        return wrapCustomSplitConfig(() => null, customSplitting, customChunk, root);
    }
    if (strategy === "unbundle") {
        return wrapCustomSplitConfig((id, { getModuleInfo }) => {
            if (id.includes("node_modules") && !(0, helper_1.isCSSIdentifier)(id)) {
                if ((0, staticImportScan_1.staticImportedScan)(id, getModuleInfo, new Map(), [])) {
                    return "vendor";
                }
                else {
                    return "async-vendor";
                }
            }
            const cwd = process.cwd();
            if (!id.includes("node_modules") && !(0, helper_1.isCSSIdentifier)(id)) {
                const extname = path_1.default.extname(id);
                return (0, utils_1.normalizePath)(path_1.default.relative(cwd, id).replace(extname, ""));
            }
        }, Object.assign(Object.assign({}, SPLIT_DEFAULT_MODULES), customSplitting), customChunk, root);
    }
    return wrapCustomSplitConfig((id, { getModuleInfo }) => {
        if (id.includes("node_modules") && !(0, helper_1.isCSSIdentifier)(id)) {
            if ((0, staticImportScan_1.staticImportedScan)(id, getModuleInfo, new Map(), [])) {
                return "vendor";
            }
        }
    }, Object.assign(Object.assign({}, SPLIT_DEFAULT_MODULES), customSplitting), customChunk, root);
});
function chunkSplitPlugin(splitOptions = {
    strategy: "default",
}) {
    return {
        name: "vite-plugin-chunk-split",
        config(c) {
            return __awaiter(this, void 0, void 0, function* () {
                yield es_module_lexer_1.init;
                const root = (0, utils_1.normalizePath)(c.root || process.cwd());
                const manualChunks = yield generateManualChunks(splitOptions, root);
                return {
                    build: {
                        rollupOptions: {
                            output: {
                                manualChunks,
                            },
                        },
                    },
                };
            });
        },
        // Delete useless import in commonjsHelpers.js, which is generated by @rollup/plugin-commonjs
        // https://github.com/sanyuan0704/vite-plugin-chunk-split/issues/8
        renderChunk(code, chunk) {
            return __awaiter(this, void 0, void 0, function* () {
                const s = new magic_string_1.default(code);
                if (chunk.fileName.includes("__commonjsHelpers__")) {
                    const [imports] = (0, es_module_lexer_1.parse)(code);
                    for (const { ss: start, se: end } of imports) {
                        s.remove(start, end);
                    }
                    return {
                        code: s.toString(),
                        map: s.generateMap({ hires: true }),
                    };
                }
                return {
                    code: code,
                    map: chunk.map || s.generateMap({ hires: true }),
                };
            });
        },
    };
}
exports.chunkSplitPlugin = chunkSplitPlugin;
//# sourceMappingURL=index.js.map